package com.squareup.sqldelight.android.paging3.rx3

import androidx.paging.PagingState
import androidx.paging.rxjava3.RxPagingSource
import com.squareup.sqldelight.Query
import com.squareup.sqldelight.Transacter
import com.squareup.sqldelight.android.paging3.QueryPagingSource
import io.reactivex.rxjava3.core.Scheduler
import io.reactivex.rxjava3.core.Single
import kotlinx.coroutines.rx3.asCoroutineDispatcher
import kotlinx.coroutines.rx3.rxSingle

internal class RxOffsetQueryPagingSource<RowType : Any>(
  queryProvider: (limit: Long, offset: Long) -> Query<RowType>,
  countQuery: Query<Long>,
  transacter: Transacter,
  scheduler: Scheduler,
) : RxPagingSource<Long, RowType>() {

  private val delegate = QueryPagingSource(
    countQuery = countQuery,
    transacter = transacter,
    queryProvider = queryProvider,
    dispatcher = scheduler.asCoroutineDispatcher(),
  )

  override fun getRefreshKey(state: PagingState<Long, RowType>) = delegate.getRefreshKey(state)

  override fun loadSingle(params: LoadParams<Long>): Single<LoadResult<Long, RowType>> = rxSingle {
    delegate.load(params)
  }
}

/**
 * Create a [RxPagingSource] that pages through results according to queries generated by
 * [queryProvider]. Queries returned by [queryProvider] should expect to do SQL offset/limit
 * based paging. For that reason, [countQuery] is required to calculate pages and page offsets.
 *
 * An example query returned by [queryProvider] could look like:
 *
 * ```sql
 * SELECT value FROM numbers
 * LIMIT 10
 * OFFSET 100;
 * ```
 *
 * Queries will be executed on [scheduler].
 */
@Suppress("FunctionName")
fun <RowType : Any> RxQueryPagingSource(
  countQuery: Query<Long>,
  transacter: Transacter,
  scheduler: Scheduler,
  queryProvider: (limit: Long, offset: Long) -> Query<RowType>,
): RxPagingSource<Long, RowType> = RxOffsetQueryPagingSource(
  queryProvider,
  countQuery,
  transacter,
  scheduler,
)
